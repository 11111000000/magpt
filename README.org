* MaGPT — Universal, Safe Git/Magit AI Assistant for Emacs
:PROPERTIES:
:DESCRIPTION: Modular and extensible AI assistant for Git in Emacs. Provider-agnostic, safety-first, designed for workflow quality and future evolution. Powered by gptel.
:END:

** Vision

MaGPT is an evolving Emacs package providing a universal AI assistant for working with Git repositories—especially via Magit. Starting as a best-of-breed commit message generator, it now introduces an extensible, task-oriented architecture for every phase of the Git workflow: status explanation, commit authoring, intent-based staging, branch naming, conflict mediation, histories, summaries, and safe previews of automated changes.

MaGPT is designed for:
- Clear, safe, reversible interactions at every step.
- Strict privacy-by-default: explicit user confirmation and minimal, maskable context.
- Smooth integration with Emacs, Magit, and gptel, without imposing new bindings or modes.
- Future growth via a clean task registry and plugin system—ready for new workflows as AI and Emacs communities evolve.

See [[#future-roadmap][Future roadmap]] for upcoming phases and philosophy details.

** Features

- High‑quality, Conventional Commit–friendly message generation from the staged diff.
- Status explanation, commit lint/fix, and branch name suggestion—all as safe, preview-only AI tasks.
- Structured, provider‑agnostic API via gptel: supports OpenAI, Ollama (local), and more.
- Magit integration: buttons and menu entries are /additional/ (never break defaults).
- Privacy & control: every data send and change is confirmed; secrets can be masked.
- Async, non-blocking UX: overlays/progress in commit buffers; panel buffer for interaction history.
- Extensible, modular core: easy addition of new tasks (patches, changelogs, rebase/todos, conflict resolution).
- Per-project =.magptrc= support for customizable language, prompts, and defaults.
- Robust test suite: UTF-8 truncation, comment boundary detection, insertion logic, JSON validation.

** Principles

- Minimal, composable task units: context gathering, prompt building, result rendering, and (optionally) applying.
- Always preview; never mutate repo state without dry-run, diff, and user confirmation.
- Only augment existing Magit/VC/project flows—no invasive hooks or rebindings.
- Local-first, cloud-optional: never leak content unless you choose to; masking is encouraged.

** Installation

Clone or place =magpt.el= into your =load-path= and require it:

#+begin_src emacs-lisp
(add-to-list 'load-path "/path/to/magpt/")
(require 'magpt)
#+end_src

Example (using use-package and straight.el):

#+begin_src emacs-lisp
(straight-use-package '(magpt :type git :host github :repo "11111000000/magpt"))
(use-package magpt
  :after gptel
  :commands (magpt-generate-commit-message magpt-commit-staged)
  :init
  (magpt-mode 1)) ; Optional: integrate "Commit with AI message" into Magit transient menus
#+end_src

MELPA support is planned for the stable release cycle.

** Quickstart

1. Stage changes (e.g. via Magit or =git add=).
2. Open a commit buffer (Magit: =C= then =c=).
3. Generate:
   - In commit buffer: =M-x magpt-generate-commit-message=
   - Or open+fill in one go: =M-x magpt-commit-staged=
4. Confirm sending the diff (see byte size/safety preview).
5. Review the suggested message at the top, edit if needed, then =C-c C-c= to commit.
6. Explore new safe tasks via =M-x magpt-show-panel= and related commands.

** Example Scenario: Calm Precision, Full Transparency

- Open Magit Status (=M-x magit-status=).
- Press =?= to open Magit Dispatch, then =e= for "Explain status": get a concise overview and risk assessment.
- Use "Stage by intent": magpt suggests logical groups for staging, which you can review and approve.
- Ask for a "Commit with AI message": always confirm what will be sent; message appears in context but is never forced.
- If conflict arises, "Explain conflict" and "Propose resolution patch" will appear—with dry-run diffs and complete control.
- The magpt panel buffer tracks all requests and responses for later review.
- Nothing is pushed or merged without your awareness—no side effects, ever.

** Commands

- =magpt-generate-commit-message=: Message from staged diff, into commit buffer or dedicated result buffer.
- =magpt-commit-staged=: (With Magit) Open commit buffer and auto-fill message.
- =magpt-mode=: Optional global minor mode; adds "[i] Commit with AI message" to Magit commit menu.
  Also adds the following entries to =magit-dispatch= (when enabled):
  - =e=: Explain status (magpt)
  - =E=: Explain hunk/region (magpt)
  - =S=: Stage by intent (magpt)
  - =A=: Apply last stage-by-intent (magpt)
  - =R=: Range/PR summary (magpt)
- Experimental, task-oriented safer commands (enable with =magpt-enable-task-registry=):
    - =magpt-explain-status=
    - =magpt-commit-lint-suggest=
    - =magpt-branch-name-suggest=
    - =magpt-show-panel=
    - =magpt-run-task= (for all registered/more experimental tasks)
    - =magpt-explain-hunk-region= (Phase 2, read-only: explain selected region or current hunk)
    - =magpt-stage-by-intent=, =magpt-stage-by-intent-apply-last= (Phase 2: suggest groups; Apply limited to whole-file stage/unstage)
    - =magpt-range-summary= (Phase 2: PR/MR summary from a commit range; text only)
    - =magpt-stage-by-intent-hunks= (Phase 2: hunk-level via unified diff; preview; safe apply to index after =git apply --cached --check=)
    - =magpt-resolve-conflict-here= (Phase 3: conflict explanation + minimal patch suggestion; preview and =git apply --check= only)

** Customization

All options are under =M-x customize-group RET magpt RET= or via =.magptrc= file for project-specific preference.

Key variables:
- =magpt-model=: LLM model name; supports gptel's provider auto-detection.
- =magpt-commit-prompt=: Prompt template; can be language-specific or project-local.
- =magpt-max-diff-bytes=: Max bytes to send for commit generation.
- =magpt-confirm-before-send=: Confirm before uploading content (shows original and send sizes; warns of truncation).
- =magpt-commit-overlay-text=: Overlay display string in commit buffer (can be localized).
- =magpt-project-root-strategy=: How to find repo root (Magit/VC/project.el).
- =magpt-enable-task-registry=: Enable experimental, extensible AI task pipeline and Panel UI.
- =magpt-transient-colorize=: Colorize MaGPT entries in Magit transient menus (default: on).
- =magpt-transient-face=: Customize face (color/style) for MaGPT entries in transients.

Other customization includes provider selection (see next section), language, and per-task options via the registry.

** Provider setup (via gptel)

- *OpenAI:*
  #+begin_src emacs-lisp
  (setq gptel-api-key (getenv "OPENAI_API_KEY"))
  #+end_src

- *Ollama/local:*
  #+begin_src emacs-lisp
  (require 'gptel)
  (setq gptel-backend (gptel-make-ollama "ollama" :host "localhost:11434"))
  ;; Set magpt-model to your local model's name (e.g., "llama3")
  #+end_src

If =magpt-model= is =nil=, inherits gptel's setting.

** Per-project configuration: =.magptrc=

=.magptrc= at your project root overrides any user options—using safe, explicit =(VARIABLE . VALUE)= Emacs Lisp alist. Example:

#+begin_src emacs-lisp
'(
  (magpt-info-language . "Русский")
  (magpt-commit-language . "English")
  (magpt-panel-auto-pop . t)
  (magpt-enable-task-registry . t)
  (magpt-model . "gpt-4.1-mini"))
#+end_src

** Magpt Panel: Workflow Transparency

The panel (=*magpt-panel*=) logs all AI tasks: requests, responses, JSON validity, notes and a safety audit. You can review exactly what was sent/received, with schema hints and contextual actions.
- Dynamic “Actions” line indicates when “Apply” is available (only for safe, reversible ops).
- Panel buttons:
  - [Copy], [JSON] — available for any entry (copy response; open in JSON buffer and pretty-print if valid).
  - [Apply] — for =stage-by-intent= plans (file-level =git add=/=git restore --staged= only, with confirmation).
  - [Open patch], [Check patch], [Apply to index] — for patch-based tasks (e.g., =stage-by-intent-hunks=); validation via =git apply --check= and optional safe apply via =git apply --cached=, always with confirm.
- Keybindings in the panel (=magpt-panel-mode=):
  - c — copy current entry’s response to the kill-ring
  - j — open current entry’s response in a JSON buffer (pretty-printed when valid)

** Security and Privacy

- User must always confirm what will be sent (both content and byte size); shows if truncation occurred.
- Secrets (tokens, keys) are never sent automatically; future versions will mask patterns.
- By default, no cloud provider; local LLMs (e.g. Ollama) are safest.
- No irreversible git operations are performed: all changes are previewed, dry-run, and confirmed.
- Apply operations:
  - File-level staging uses only =git add= and =git restore --staged= (reversible).
  - Patch-based tasks use =git apply --check= for validation and optional =git apply --cached= (index-only), always with explicit preview and confirmation.

** Extending MaGPT

MaGPT’s task registry makes it simple to add new “tasks”:
- Each task specifies:
  - Context function: gathers just enough from git or Emacs.
  - Prompt builder: formats, marks, imposes output schema.
  - Renderer: shows in =*magpt-panel*=, commit buffer, or as a diff/patch.
  - (Optionally) Safe apply function: always dry-run with explicit user validation.
- Adding a new task:
  1. Write context, prompt, render, (optionally apply) code in Lisp.
  2. Register with =magpt-register-task=.
  3. Instantly available via =magpt-run-task=.
- See code for examples.

** Task Examples (Current & Planned)

- *Observe:* Explain repository status, status by file/hunk, staged changes, risk summary, history summarization.
- *Suggest:* Commit message from diff, branch names, PR/MR summaries, lint/fixups, intent-based staging groups.
- *Recommend & Preview:* Group and preview staging actions, minimal patch suggestions for hunks, safe rebase plans.
- *Resolve & Mediate:* Explain merge conflicts; propose minimal resolution patches with diff previews (never auto-merge).
- *Release/Document:* Generate changelogs, release notes; PR/MR templates from history.
- *Search/Orient:* Planned: answer questions about code (“Q&A”) strictly on samples, respecting privacy.

** Roadmap & Release Plan

See [[#future-roadmap][Future roadmap]] for the envisioned “Observe” ➔ “Recommend” ➔ “Resolve” ➔ “Release” cycle (“crossing the river gently”).

** [[#future-roadmap][Future roadmap]]

- *Phase 0 ("Foundation Hardening")*
  - Robustify core pipeline and overlay UX, add mandatory test harness, build project task registry, stabilize overlays/logs.
  - /Exit criteria: no change in observable default behavior; new features are opt-in and reversible./

- *Phase 1 ("Observe")*
  - Status explain, commit lint/fix, branch name suggest as /read-only/, with all results in the panel and no mutations.
  - /Exit criteria: all workflows are preview-only, with clear user review and no changes to repo state./

- *Phase 2 ("Recommend")*
  - Explain hunk/region, suggest stage-by-intent groups, range/PR summary.
  - Safe, atomic “apply” for naturally-reversible operations (stage/unstage).
  - /Exit criteria: nothing changes repo unless user explicitly confirms per action./

- *Phase 3 ("Resolve")*
  - Explain conflict with patch suggest (ediff/dry-run), safe rebase plan preview.
  - All actions are explicit, dry-run only, cancelable at any time.

- *Phase 4+ ("Release/Extend")*
  - Live changelog/release notes, PR/MR templates (text only), telemetry (local).
  - RAG/code search is future interest, gated by privacy and clear use.

** Test Practices

- ERT-based suite: UTF-8 truncation, insertion, overlay teardown, JSON detection.
- Property tests for safety gates and text boundary detection.
- No dependency on LLM at test time: gptel is stubbed/mocked for portable CI.

** Tips

- Keep =magpt-enable-task-registry= off for pure commit message generation (as in v1.0.x).
- Only enable experimental tasks/project features (=magpt-enable-task-registry=, etc.) one-by-one per your workflow needs.
- Review =*magpt-panel*= to understand exactly what goes to and comes from the LLM.
- Prefer local models while evaluating.

** Troubleshooting

- “No staged changes found”?
  - Stage them via Magit or =git add=.
- “Commit message not inserted”?
  - If no commit buffer, result is shown in /magpt-commit/ (copied to kill-ring).
- “Model responds slowly/empty”?
  - Try a different gptel backend or review provider logs.
- “Overlay stuck”?
  - Should self-clean; try clearing commit buffer or re-opening.

** License

MIT. See [[file:LICENSE][LICENSE]].

** Links

- Source: https://github.com/11111000000/magpt
- gptel: https://github.com/karthink/gptel
- Magit: https://magit.vc/

